-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/hw04#readme</a>
@package hw04
@version 0.1.0.0


-- | Comonad-19 hw
module Comonad.Comonad

-- | ListZipper
--   
--   Taken from presentation
data ListZipper a
LZ :: [a] -> a -> [a] -> ListZipper a

-- | Go to left or right
--   
--   Taken from presentation
listLeft :: ListZipper a -> ListZipper a

-- | Go to left or right
--   
--   Taken from presentation
listRight :: ListZipper a -> ListZipper a

-- | Write to list
--   
--   Taken from presentation
listWrite :: a -> ListZipper a -> ListZipper a

-- | ListZipper to List
--   
--   Taken from presentation
toList :: ListZipper a -> Int -> [a]

-- | Take tail
--   
--   Taken from presentation
iterateTail :: (a -> a) -> a -> [a]

-- | Make move
--   
--   Taken from presentation
genericMove :: (z a -> z a) -> (z a -> z a) -> z a -> ListZipper (z a)

-- | 2D Grid
--   
--   Taken from presentation
newtype Grid a
Grid :: ListZipper (ListZipper a) -> Grid a
[unGrid] :: Grid a -> ListZipper (ListZipper a)

-- | Go to up or down
--   
--   Taken from presentation
up :: Grid a -> Grid a

-- | Go to up or down
--   
--   Taken from presentation
down :: Grid a -> Grid a

-- | Go to left or right
--   
--   Taken from presentation
left :: Grid a -> Grid a

-- | Go to left or right
--   
--   Taken from presentation
right :: Grid a -> Grid a

-- | Read value on grid
--   
--   Taken from presentation
gridRead :: Grid a -> a

-- | Write value on grid
--   
--   Taken from presentation
gridWrite :: a -> Grid a -> Grid a

-- | Grid to list
--   
--   Taken from presentation
toListG :: Grid a -> Int -> [[a]]

-- | Take vertical list and horizontal
--   
--   Taken from presentation
horizontal :: Grid a -> ListZipper (Grid a)

-- | Take vertical list and horizontal
--   
--   Taken from presentation
vertical :: Grid a -> ListZipper (Grid a)

-- | Type of people
data Type
Infected :: Type
Immune :: Type
Healthy :: Type
Ill :: Type

-- | Person data
data Person
Person :: Type -> Int -> StdGen -> Person
[type'] :: Person -> Type
[count] :: Person -> Int
[get] :: Person -> StdGen

-- | Show Grid
--   
--   Why not instance Show? Because size
showWithInt :: Grid Person -> Int -> String

-- | Make full healthy person
makeStartPerson :: Int -> Person

-- | Make ListZipper of random values
makeListOfInt :: Int -> ListZipper Int

-- | Generate random Grid of Int
randomIntGrid :: Int -> Grid Int

-- | Generate random Grid of Person
randomPersonGrid :: Int -> Grid Person

-- | Make start field
makeField :: Int -> Grid Person

-- | Make "null pacient"
makeInfected :: Grid Person -> Grid Person

-- | Take neighbours
neighbours :: [Grid a -> Grid a]

-- | Is Person cough
isCough :: Person -> Bool

-- | Count of "cough" from neighbours
countCoughs :: [Person] -> Int

-- | Count of "cough" contacts
contacts :: Grid Person -> Int

-- | Simulating contact with person
oneContact :: Double -> StdGen -> Int -> (Bool, StdGen)

-- | Tick for one person with returning person
personTick :: Double -> Int -> Int -> Int -> Person -> Grid Person -> Person

-- | Tick for one person and write it to Grid
tickOne :: Double -> Int -> Int -> Int -> Grid Person -> Person

-- | Tick for all person
tick :: Double -> Int -> Int -> Int -> Grid Person -> Grid Person
instance GHC.Show.Show Comonad.Comonad.Person
instance GHC.Base.Functor Comonad.Comonad.Grid
instance Control.Comonad.Comonad Comonad.Comonad.Grid
instance GHC.Base.Functor Comonad.Comonad.ListZipper
instance Control.Comonad.Comonad Comonad.Comonad.ListZipper


-- | File system file
module FileSystem.FileSystem

-- | Focus lens on folder with name
cd :: FilePath -> Traversal' FS FS

-- | Focus on names on folder
ls :: Traversal' FS FilePath

-- | Focus on file name, if exists
file :: FilePath -> Traversal' FS FilePath

-- | Scan file system and make FS class
getDirectory :: FilePath -> IO FS

-- | Content lens
contents' :: Lens' FS [FS]

-- | File system
data FS
Dir :: FilePath -> [FS] -> FS
[name] :: FS -> FilePath
[contents] :: FS -> [FS]
File :: FilePath -> FS
[name] :: FS -> FilePath


-- | Point hw class
module Geometry.Point

-- | Data point for all task 01
data Point
Point :: Int -> Int -> Point
[xPosition] :: Point -> Int
[yPosition] :: Point -> Int

-- | Plus operation for Point
plus :: Point -> Point -> Point

-- | Minus operation for Point
minus :: Point -> Point -> Point

-- | Distance between points
distance :: Point -> Point -> Double

-- | Fast distance from Heron Sqrt between points
fastDistance :: Point -> Point -> Double

-- | Scalar product for Point
--   
--   @see <a>https://en.wikipedia.org/wiki/Dot_product</a>
scalarProduct :: Point -> Point -> Int

-- | Cross product for Point
--   
--   See <a>https://encyclopediaofmath.org/wiki/Pseudo-scalar_product</a>
crossProduct :: Point -> Point -> Int

-- | Take perimeter of polygon
--   
--   See fastDistance
perimeter :: [Point] -> Double

-- | Take fast perimeter of polygon
--   
--   See distance
longPerimeter :: [Point] -> Double

-- | Take double area of polygon
--   
--   See <a>https://en.wikipedia.org/wiki/Shoelace_formula</a>
doubleArea :: [Point] -> Int
instance GHC.Classes.Eq Geometry.Point.Point
instance GHC.Show.Show Geometry.Point.Point


-- | Main module of HalyavaScript hw
module HalyavaScript.Script

-- | Type for script
class (Show a) => ScriptType a
defaultValue :: ScriptType a => a

-- | Class script
class Script interpreter where {
    type family Variable interpreter :: * -> *;
}

-- | Create a variable with this type
createType :: (Script interpreter, ScriptType a) => a -> interpreter (Variable interpreter a)

-- | Create int
int :: Script interpreter => Int -> interpreter (Variable interpreter Int)

-- | Create Double
double :: Script interpreter => Double -> interpreter (Variable interpreter Double)

-- | Create Bool
bool :: Script interpreter => Bool -> interpreter (Variable interpreter Bool)

-- | Create String
string :: Script interpreter => String -> interpreter (Variable interpreter String)

-- | Get variable for real haskell
getType :: (Script interpreter, ScriptType t) => Variable interpreter t -> interpreter t

-- | Get Script variable from real
up :: (Script interpreter, ScriptType a) => a -> interpreter a

-- | Get Script variable from real
up :: (Script interpreter, Applicative interpreter, ScriptType a) => a -> interpreter a

-- | Separator of command
(@#) :: Script interpreter => interpreter a -> interpreter b -> interpreter b

-- | Separator of command
(@#) :: (Script interpreter, Monad interpreter) => interpreter a -> interpreter b -> interpreter b

-- | Create new variable
create :: (Script interpreter, ScriptType a) => interpreter (Variable interpreter a) -> (Variable interpreter a -> interpreter b) -> interpreter b

-- | Create new variable
create :: (Script interpreter, Monad interpreter, ScriptType a) => interpreter (Variable interpreter a) -> (Variable interpreter a -> interpreter b) -> interpreter b

-- | Function of one argument
sFun1 :: Script interpreter => (interpreter a -> interpreter b) -> interpreter (a -> interpreter b)

-- | Function of one argument
sFun1 :: (Script interpreter, Applicative interpreter) => (interpreter a -> interpreter b) -> interpreter (a -> interpreter b)

-- | Function of two argument
sFun2 :: (Script interpreter, Applicative interpreter) => (interpreter a -> interpreter b -> interpreter c) -> interpreter (a -> b -> interpreter c)

-- | Functiono of three argument
sFun3 :: (Script interpreter, Applicative interpreter) => (interpreter a -> interpreter b -> interpreter c -> interpreter d) -> interpreter (a -> b -> c -> interpreter d)

-- | While
sWhile :: Script interpreter => interpreter Bool -> interpreter () -> interpreter ()

-- | While
sWhile :: (Script interpreter, Monad interpreter) => interpreter Bool -> interpreter () -> interpreter ()

-- | If
sIf :: (Script interpreter, Monad interpreter) => interpreter Bool -> interpreter () -> interpreter () -> interpreter ()

-- | <a>Functor</a>
(@.) :: (Script interpreter, Monad interpreter) => interpreter (a -> b) -> interpreter a -> interpreter b

-- | "Cut monad"
(@>>=) :: Script interpreter => interpreter (a -> interpreter b) -> interpreter a -> interpreter b

-- | Apply to variable real-haskell variable
(@@=) :: (Script interpreter, Monad interpreter, ScriptType a) => Variable interpreter a -> a -> interpreter ()

-- | Set to variable another variable
(@=) :: (Script interpreter, ScriptType a) => Variable interpreter a -> interpreter a -> interpreter ()

-- | Set to variable another variable
(@=) :: (Script interpreter, Monad interpreter, ScriptType a) => Variable interpreter a -> interpreter a -> interpreter ()

-- | Equals
(@==) :: (Script interpreter, Eq a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | Not equals
(@!=) :: (Script interpreter, Eq a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | Greater
(@>) :: (Script interpreter, Ord a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | Greater or equals
(@>=) :: (Script interpreter, Ord a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | Less
(@<) :: (Script interpreter, Ord a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | Less or equals
(@<=) :: (Script interpreter, Ord a, ScriptType a) => interpreter a -> interpreter a -> interpreter Bool

-- | And
(@&&) :: (Script interpreter, Ord a, ScriptType a) => interpreter Bool -> interpreter Bool -> interpreter Bool

-- | Or
(@||) :: (Script interpreter, Ord a, ScriptType a) => interpreter Bool -> interpreter Bool -> interpreter Bool

-- | Plus
(@+) :: (Script interpreter, Num a, ScriptType a) => interpreter a -> interpreter a -> interpreter a

-- | Multiply
(@*) :: (Script interpreter, Num a, ScriptType a) => interpreter a -> interpreter a -> interpreter a

-- | Minus
(@-) :: (Script interpreter, Num a, ScriptType a) => interpreter a -> interpreter a -> interpreter a
infix 4 @>
infixl 7 @*
infixl 6 @+
infixl 6 @-
infix 4 @<
infix 4 @<=
infix 4 @>=
infix 4 @==
infix 4 @!=
infix 4 @=
infixr 3 @&&
infixr 2 @||
infixl 1 @#
infixr 0 @.
infixr 0 @>>=

-- | Executor
newtype Intepreter state a
Intepreter :: ST state a -> Intepreter state a
[run] :: Intepreter state a -> ST state a

-- | Runner for program
runP :: (forall s. Intepreter s a) -> a
instance GHC.Base.Monad (HalyavaScript.Script.Intepreter state)
instance GHC.Base.Applicative (HalyavaScript.Script.Intepreter state)
instance GHC.Base.Functor (HalyavaScript.Script.Intepreter state)
instance HalyavaScript.Script.Script (HalyavaScript.Script.Intepreter state)
instance HalyavaScript.Script.ScriptType GHC.Types.Int
instance HalyavaScript.Script.ScriptType GHC.Types.Bool
instance HalyavaScript.Script.ScriptType GHC.Base.String
instance HalyavaScript.Script.ScriptType GHC.Types.Double


-- | ToJavaScript HW
module HalyavaScript.JavaScript

-- | Store recursive function from count functions variables and indencies
--   to string
newtype Store a
Store :: (Int -> Int -> Int -> String) -> Store a
[_recursive] :: Store a -> Int -> Int -> Int -> String

-- | Run toJS function
runR :: Store a -> String
instance HalyavaScript.Script.Script HalyavaScript.JavaScript.Store


-- | Hash table class
module HashTable.HashTable

-- | Create new hash table structure
newCHT :: IO (ConcurrentHashTable k v)

-- | Get element from hash table
getCHT :: (Hashable k, Eq k) => k -> ConcurrentHashTable k v -> IO (Maybe v)

-- | Put element to hash table
putCHT :: (Hashable k, Eq k) => k -> v -> ConcurrentHashTable k v -> IO ()

-- | Get size of hash table
sizeCHT :: ConcurrentHashTable k v -> IO Int


-- | Expression file
module MonteCarlo.Expr

-- | Expr type for Expr class
data ExprType
X :: ExprType
Number :: Double -> ExprType

-- | Expression class
data Expr a
[ExprNum] :: ExprType -> Expr ExprType
[ExprPlus] :: Expr ExprType -> Expr ExprType -> Expr ExprType
[ExprMinus] :: Expr ExprType -> Expr ExprType -> Expr ExprType
[ExprProduct] :: Expr ExprType -> Expr ExprType -> Expr ExprType
[ExprDivide] :: Expr ExprType -> Expr ExprType -> Expr ExprType
[ExprSin] :: Expr ExprType -> Expr ExprType
[ExprCos] :: Expr ExprType -> Expr ExprType
[ExprTg] :: Expr ExprType -> Expr ExprType
[ExprPower] :: Expr ExprType -> Int -> Expr ExprType

-- | Evaluate expression
evaluate :: Expr ExprType -> Double -> Double


-- | See <a>https://en.wikipedia.org/wiki/Monte_Carlo_method</a>
module MonteCarlo.MonteCarlo

-- | Evaluate parallel Monte-Carlo formula
parrallelMonteCarlo :: Expr ExprType -> Int -> Double -> Double -> Double

-- | Evaluate consistently Monte-Carlo formula
consistentlyMonteCarlo :: Expr ExprType -> Int -> Double -> Double -> Double
