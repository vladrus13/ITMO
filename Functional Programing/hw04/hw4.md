# Haskell: ДЗ 4 -- Строгость. Многопоточность. Продвинутые типы. Линзы. Комонады.

## Дедлайн 10 January 2021 23:59 (UTC+3).

Все требования для прошлых домашних заданий справедливы и для этого домашнего задания.

Для форматирования допускается использовать как стандартный style guide, так и [ormolu](https://hackage.haskell.org/package/ormolu).

Ссылка для сдачи: https://classroom.github.com/a/VIlaYlPp.

В сумме за ДЗ можно получить до 20.5 баллов .

Распределение баллов:
1. Геометрия: 2 балла + 0.5 балла бонус
2. Интегрируемся: 2 балл
3. Хэш таблица: 3 балла
4. HalyavaScript: 2 балла
5. HalyavaScript to Javascript: 4 балла
6. FS lens: 2 балл
7. FS lens traversals: 1 балл
8. Comonad-19: 4 балла

## Задание 1. Геометрия
В данном задании от вас требуется создать дататайп `Point`, который будет представлять точку в двумерном пространстве с целочисленными координатами.

Затем реализуйте функции для работы с точками:
```haskell
plus          :: Point -> Point -> Point
minus         :: Point -> Point -> Point
scalarProduct :: Point -> Point -> Int
crossProduct  :: Point -> Point -> Int
-- Выше имеется в виду псевдоскалярное произведение: (x1, y1) * (x2, y2) = x1 * y2 − x2 * y1
```

Затем реализуйте функции, которые принимают на вход многоугольник без самопересечений, заданный координатами его вершин в порядке против часовой стрелки. Многоугольник может быть как выпуклый, так и не выпуклый.
```haskell
perimeter  :: [Point] -> Double -- Считает периметр
doubleArea :: [Point] -> Int    -- Считает удвоенную площадь
```
Функции должны обрабатывать многоугольники с количеством точек до $10^7$ за 1-2 секунды.

#### Усложненное задание
Необходимо написать несколько тестов измеряющих перфоманс, используя пакет `criterion`.
Напишите для тестов более наивную реализацию и сравните их по времени и памяти.

## Задание 2. Интегрируемся

Реализуйте интегрирование методом Монте-Карло для какой-нибудь сложной аналитической функции одного аргумента (`1/tg(x^2)-cos(x)` например) по заданному отрезку.

Реализуйте два способа запуска интегрирования: последовательный и многопоточный.

Реализауйте benchmark с помощью criterion. Убедитесь что на достаточно больших количества итераций метода параллельная реализация кратно опережает последовательную.

## Задание 3. Хэш таблица
В данном задании от Вас требуется написать хэш таблицу, которая способна обрабатывать запросы из нескольких потоков одновременно. Хэш таблица должна работать довольно быстро для $10^5$ параллельных запросов.

Необходимо реализовать следующий дататайп:
```haskell
data ConcurrentHashTable k v = ...your code here..
```
а затем следующие функции:

```haskell
newCHT  :: IO (ConcurrentHashTable k v)
getCHT  :: k -> ConcurrentHashTable k v -> IO (Maybe v)
putCHT  :: k -> v -> ConcurrentHashTable k v -> IO ()
sizeCHT :: ConcurrentHashTable k v -> IO Int
```
Сигнатуры функций даны без констреинтов, потому что они будут зависеть от реализации.

Ваша реализация должна удовлетворять следующим условиям:
* выполнять все операции `put` в конечном итоге, если все потоки завершаются
* быть устойчива к асинхронным исключениям: асинхронное исключение не должно делать состояние хэш-таблицы неконсистентным
* использовать $O(n)$ памяти, где $n$ - количество добавленных элементов

Для реализации можете использовать примитивы для конкаренси, такие как `MVar`, `TVar`, `TMVar` и другие.

#### Усложненное задание
Необходимо написать несколько тестов измеряющих перфоманс, используя пакет `criterion`. Также необходимо написать несколько тестов, проверяющих корректность операций и устойчивость к асинхронным исключениям.

## Задание 4. HalyavaScript

В данном задании от Вас потребуется реализовать новый язык программирования, который назовём HalyavaScript.

HalyavaScript -- статически типизируемый язык программирования, повторяющий основные конструкции языка JavaScript.
Реализовать HalyavaScript требуется в виде eDSL на Haskell, таким
образом получая type inference и parsing из коробки.
Ваша реализация HalyavaScript должна поддерживать как минимум конструкции `if` и `while`.

Ваш DSL HalyavaScript должен поддерживать любые три типа из следующих (разрешается поддерживать больше типов):

 * `Int32` (конвертируется в `Number`)
 * `Double` (конвертируется в `Number`)
 * `String`
 * `Boolean`
 * Функции от одного и двух агрументов

Конкретный синтаксис Вам предлагается разработать самим.
Для вдохновения можно использовать пример ниже:

```haskell
-- | For a given @x@ calculates @ceiling (log2 (a))@
log2 =
  sFun1 $ \a logCnt ->
  sWithVar 0 $ \accum ->
    accum @= 1 #
    logCnt @= 0 #
    sWhile (a @> eRead accum)
      ( accum @= eRead accum + eRead accum #
        logCnt @= eRead logCnt + 1
      )
```
Обратите внимание, что у данной функции специально отсутствует сигнатура типа, чтобы Вы имели возможность придумать все типы сами.

Для реализации можете использовать GADT, tagless final, Free Applicatives (**не** Free Monads) и другие продвинутые подходы языка.

Реализуйте интерпретатор Вашего языка, который будет интерпретировать код написанный на HalyavaScript.

К реализации должен быть приложен простой пример программы, в котором задействованы три разных типа.

## Задание 5. HalyavaScript to JavaScript

Реализуйте еще один интерпретатор, который будет конвертировать код на HalyavaScript в строковое представление.

Например, код из предыдущего задания должен выглядеть как-то так. Необязательно точь-в-точь так же.

```javascript
function(v0){
  var v1=0;
  var v2=0;
  v2=1;
  v1=0;
  while ((v0) > (v2)) {
    v2=(v2) + (v2);
    v1=(v1) + (1);
  }
  return v1
}
```

Напишите несколько unit-тестов, которые конвертируют код в строку и сравнивают ее с ожидаемым результатом.

## Линзы

### Задание 6: FileSystem lenses

Разрешается использовать пакет `microlens`.

Задан тип данных, которым можно представить простое дерево файловой системы:
(record-syntax в суммах типов это все еще плохо)

```haskell
data FS 
    = Dir 
    { name     :: FilePath  -- название папки, не полный путь
    , contents :: [FS]
    }
    | File
    { name     :: FilePath  -- название файла, не полный путь
    }
```
Создайте функцию, которая «сканирует» заданную директорию и создаёт объект типа `FS` наподобие функции [`getDirectory'`](https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#v:getDirectory-39-).

После этого создайте базовые линзы и призмы Вашего типа данных.

### Практика на линзы

> Блок практики не оценивается баллами. Он лишь предоставляет набор команд, которые полезно научиться реализовывать в одну строку при помощи линз, прежде чем приступать к дальнейшим заданиям. Все команды в списке очень простые, но если Вы не можете выполнить и их, значит, Вы не до конца разобрались с линзами, и выполнять дальнейшие задания ещё рано.

1. Список поддеревьев папки для `Dir`, иначе пустой список.
2. `Maybe` с именем директории, если `Dir`, или `Nothing` иначе.
3. Имя файла, если `File`, или пустую строку иначе.
4. Изменить имя корня дерева на `/`.
5. Добавить произвольный суффикс к имени корня дерева.
6. Получить имя самой первой папки в списке поддиректорий (`Nothing`, если такой нет).
7. Получить список имён только `File` из `Dir` (нерекурсивно).

### Задание 7: Обходы FS

Реализуйте следующие `Lens` или `Traversal`:

1. `cd`: перейти в поддиректорию с указанным именем.
2. `ls`: получить список имён содержимого директории.
3. `file`: получить имя конкретного `File`, если он существует.

В итоге должна быть возможность делать нечто похожее:

```haskell
myDir ^?  cd "A" . cd "B" . file "C"  -- Just "C" при существовании myDir/A/B/C
myDir ^.. cd "A" . cd "B" . ls        -- получить содержимое myDir/A/B/
```

## Задание 8: Comonad-19

Задача: реализовать симуляцию распространения Covid-19 на двумерной сетке.

Нужно реализовать модель "Вероятность заражения" из https://kapter.github.io/outbreak с дополнением в виде учета повторно заболевших.

Задаются параметры:
* Вероятность заражения (0 < p < 1) -- оценка отношения приведших к заражению числа контактов к общему числу контактов между конкретно взятым инфицированным и его соседями
* Инкубационный период (дни)
* Болезнь с симптомами (дни)
* Длительность иммунитета (дни) -- сколько дней человек не может повторно заразиться после выздоровления


(Человек, у которого болезнь протекает в инкубационном периоде либо с активными симптомами, способен передать инфекцию незараженному соседу с вероятностью p)
Используйте тип Grid из лекции:
```
newtype Grid a = Grid { unGrid :: ListZipper (ListZipper a) }
```
Реализуйте функции для:
* получения двумерной сетки с одним зараженным посередине
* выполнения одного шага симуляции
* распечатывания всей сетки: # для активно зараженного, @ для выздоровевшего с активным иммунитетом и пустое место для здорового без иммунитета

P.S. для простоты инициализируйте все ячейки объектом типа StdGen и используйте его в качестве случайного генератора всякий раз, когда возникнет необходимость сгенерировать случайное число в клетке (когда клетка находится в инкубационном периоде либо активной стадии болезни). Если в вашей реализации на диагоналях получатся одинаковые StdGen — нестрашно.
