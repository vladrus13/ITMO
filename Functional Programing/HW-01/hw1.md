# Haskell: ДЗ 1 -- Базовые конструкции языка и не только

Первое домашнее задание проверяет понимание базовых конструкций языка. А также стандартные функции и базовые интерфейсы.
Обратите внимание, что задание соответствует материалу, который рассказан в темах со 2 по 4ю [отсюда](https://github.com/jagajaga/FP-Course-ITMO).

В качестве вспомогательного материала про тестирование
при выполнении этого ДЗ рекомендуется использовать данные [слайды](https://slides.com/fp-ctd/lecture-55).

Некоторые задания имеют усложнённые версии, которые необходимо выполнять **дополнительно к базовой**, но они также будут оценены дополнительными баллами.

В данном домашнем задании от Вас требуется познакомиться с некоторыми библиотеками для тестирования и реализовать тесты с помощью них.

Тесты должны находиться в директории `test/`

Тесты должны запускаться командной `stack test`.

В заданиях явно указано, какие тесты для них должны быть реализованы.

При выполнении домашних заданий, пожалуйста, используйте резолвер `lts-16.5`.

# Срок сдачи

00:00 (UTC+3) 5 Октября 2020.

## Блок 1:  Алгебраические типы данных

В этом блоке разрешено использовать автоматический `deriving` только для `Show`. Остальные инстансы необходимо реализовывать самостоятельно.

### Задание 1: Дни недели

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

Определите свой тип данных для _Дней недели_. Реализуйте следующие функции:

1. `nextDay`: возвращает следующий за переданным день недели.
2. `afterDays`: возвращает день недели, который наступит после заданного через переданное число дней.
3. `isWeekend`: проверяет, является ли день недели выходным.
4. `daysToParty`: выводит число дней, оставшихся до пятницы.

### Задание 2: Натуральные числа

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (оцениваются дополнительными баллами).

#### Базовое задание

Этот тип данных для натуральных чисел определяется следующим образом:

```haskell
data Nat = Z | S Nat
```

Реализуйте следующие операции (которые должны быть реализованы полностью самостоятельно):

1. Сложение двух натуральных чисел.
2. Умножение двух натуральных чисел.
3. Вычитание натуральных чисел.
4. Превращение целых чисел в натуральные и наоборот.
5. Проверка натуральных чисел на равенство.
6. Сравнение натуральных чисел.

#### Усложнённая версия

Дополнительно требуется реализовать следующие функции:

7. Проверка натурального числа на чётность.
8. Целочисленное деление натуральных чисел.
9. Остаток от деления натурального числа на другое.

### Задание 3: Растительность

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

Тип данных для двоичного дерева имеет два конструктора:
1. Лист дерева, не содержит данных.
2. Узел дерева. Содержит _непустой_ список одинаковых значений и имеет двух детей.

_Двоичное дерево_ называется _двоичным деревом поиска_ если оно удовлетворяет следующему условию: значения всех элементов в левом поддереве меньше значения в узле, а значения элементов в правом поддереве больше значения в узле.

Реализуйте следующие операции с _двоичным деревом поиска_:

1. Проверка дерева на пустоту.
2. Подсчёт размера дерева (то есть числа элементов в нём).
3. Поиск заданного элемента в дереве (используйте тот факт, что дерево является деревом поиска).
4. Вставка нового элемента в _двоичное дерево поиска_. Если вставляемый элемент уже находится в дереве, то необходимо добавить его в список того узла, в котором этот элемент находится. Тут следует обратить внимание, что если в узле дерева есть список элементов, то этот список всегда непустой.
5. Функцию `fromList`, которая создаёт дерево из списка элементов.
6. Функцию, которая удаляет заданный элемент из дерева.

## Блок 2: Сворачиваемся

### Задание 1: Инстанс Foldable для Tree

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (оцениваются дополнительными баллами).

В этом задании **обязательно** использовать расширение языка `-XInstanceSigs` и указывать типы функций в инстансах.
При этом необходимо реализовать обе функции `foldMap` и `foldr`.

Реализуйте инстанс `Foldable` для типа `Tree`.
Инстанс должен быть реализован таким образом, чтобы выполнялось свойство: `toList . fromList ≡ sort`.

### Задание 2: Разбиваемся

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов. Property-based тесты по желанию (оцениваются дополнительными баллами).

#### Базовая версия

Используя свёртку, реализуйте функцию `splitOn`, которая разбивает список на подсписки по элементу.

```haskell
ghci> splitOn '/' "path/to/file"
["path", "to", "file"]
```

Стоит обратить внимание, что функция `splitOn` всегда возвращает непустой список элементов. Это должно быть отражено в типе. Пример приведён для обычного списка, хотя это решение не полностью корректное.

#### Усложнённая версия

Дополнительно реализуйте функцию (опять же, используя свёртку) `joinWith`, обратную `splitOn`. При этом Ваши реализации должны удовлетворять свойству:

`joinWith x . splitOn x ≡ id`.

```haskell
ghci> joinWith '/' ["path", "to", "file"]
"path/to/file"
```

Стоит обратить внимание на то, что функция `joinWith` принимает непустой список.

## Блок 3: Моноиды

### Задание 1

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

#### Базовая версия

Напишите функцию, принимающую список списков внутри `Maybe` и возвращающую конкатенацию всех внутренних списков.

```haskell
ghci> maybeConcat [Just [1,2,3], Nothing, Just [4,5]]
[1,2,3,4,5]
```

#### Усложнённая версия

Функция должна принимать произвольный набор `Either`, где и `Left` и `Right` содержат некоторые моноидальные элементы, и необходимо вернуть пару из результатов моноидального объединения отдельно элементов внутри `Left` и отдельно элементов внутри `Right`.

```haskell
ghci> eitherConcat [Left (Sum 3), Right [1,2,3], Left (Sum 5), Right [4,5]]
(Sum {getSum = 8}, [1,2,3,4,5])
```

### Задание 2

**Тесты:** Это задание необходимо протестировать при помощи простых unit-тестов.

#### Базовая версия

Реализуйте инстансы алгебраических классов типов для следующих структур данных. Ваши инстансы должны удовлетворять законам для этих структур.

1. `Semigroup` для `data NonEmpty a = a :| [a]`.
2. `Semigroup` для типа данных `data ThisOrThat a b = This a | That b | Both a b`.

#### Усложнённая версия

Дополнительно реализуйте следующие инстансы:

1. `Semigroup` и `Monoid` для строк, объединяемых при помощи `'.'`.

```haskell
ghci> Name "root" <> Name "server"
Name "root.server"
```

2. `Semigroup` и `Monoid` для `newtype Endo a = Endo { getEndo :: a -> a }`.
