# Поиск кратчайшего пути в распределённой системе

В этом задании вы реализуете алгоритм поиска кратчайшего пути от каждого узла распределённой системы до узла-инициатора. 

## Постановка задачи

В файле [`src/Process.kt`](src/Process.kt) находится описание интерфейса, который вам предстоит реализовать.
Свой код вы должны писать на языке Kotlin в файле [`src/ProcessImpl.kt`](src/ProcessImpl.kt). 

Допустима также реализация на Java. Для этого, как и в предыдущем задании, удалите `ProcessImpl.kt` и вместо него напишите файл
`ProcessImpl.java` с классом `dijkstra.ProcessImpl`, который реализует интерфейс `dijkstra.Process` и имеет 
публичный конструктор, принимающий ссылку на объект реализующий интерфейс `dijkstra.system.environment.Environment`. 

### Окружение процесса

В этом задании распределённая система рассматривается как ориентированный взвешенный граф, в котором у каждого узла `v` есть множество соседей `N`. 

Каждому из процессов системы будет присвоен уникальный идентификатор. Через ссылку на объект
[`Environment`](src/system/environment/Environment.kt) ваш процесс
может узнать конфигурацию системы, общаться с другими процессами и сообщать об останове дифендирующего вычисления:

* `env.pid` &mdash; возвращается идентификатор вашего процесса.
* `env.neighbours` &mdash; возвращает множество процессов-соседей вашего процесса, при этом для каждого процесса-соседа указано расстояние до него. 
* `env.send(dstId, message)` &mdash; посылает сообщение процессу с идентификатором `dstId`. При этом топология сети неполная: ваш процесс может послать сообщение процессу `u` только если `u` является соседом вашего процесса, либо ваш процесс является соседом `u`.
* `env.finishExecution()` &mdash; сообщает о завершении вычисления. Этот метод может быть вызван лишь один раз, после чего вычисление будет считаться
завершённым.

Методы вашего класса [`ProcessImpl`](src/ProcessImpl.kt) 
будут вызываться из главного потока процесса в следующих случаях:

* `onMessage(srcId, message)` &mdash; вызывается при получении сообщения от другого процесса с номером `srcId`.
  Между каждой парой процессов гарантируется FIFO порядок передачи сообщений.
* `startComputation()` &mdash; сообщает данному процессу, что он должен стать инициатором в алгоритме вычисления кратчайшего пути. Гарантируется, что только
один процесс будет выбран инициатором.
* `getDistance()` &mdash; вызывается после завершения вычисления. Процесс должен сообщить кратчайшее расстояние от него до инициатора,
или `null`, если не существует такого пути.

  
### Работа с сообщениями

Каждое сообщение должно являться объектом класса-наследника типа [`Message`](src/Message.kt).
Каждый новый тип сообщения должен быть описан в том же файле, что и базовый тип `Message`.

Тип сообщения, хранящего данные, создаётся следующим образом:
 
```kotlin
sealed class Message

data class MessageWithData(val data: Int) : Message()
```

Тип сообщения, не хранящего данных (сообщения-маркера), создаётся следующим образом:
 
```kotlin
sealed class Message

object MarkerMessage : Message()
```

## Тестирование

Тестирования реализации происходит путем запуска теста [`SolutionTest`](test/solution/SolutionTest.kt). 
Из командной строки: `./gradlew test`. 

Тест создаёт случайный граф, выбирает случайным образом процесс-инициатор, вызывает метод
`startComputation()` у процесса-инициатора и дожидается сигнала о завершении вычисления.

После получения сигнала о завершении вычисления тест вызывает метод `getDistance()` у 
каждого процесса, проверяя правильность вычисления кратчайшего пути.
## Формат сдачи

Выполняйте задание в этом репозитории. 
**Код процесса должен быть реализован в одном файле [`src/ProcessImpl.kt`](src/ProcessImpl.kt) или `src/ProcessImpl.java`,
все типы сообщений должны быть описаны в одном файле [`src/Message.kt`](src/Message.kt)**.

Инструкции по сдаче заданий находятся в 
[этом документе](https://docs.google.com/document/d/1GQ0OI_OBkj4kyOvhgRXfacbTI9huF4XJDMOct0Lh5og). 
