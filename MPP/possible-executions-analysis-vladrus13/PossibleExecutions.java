import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public class PossibleExecutions {

    private static BufferedWriter writer;

    static class State {
        public State parent = null;
        public final int P, Q, a, b;
        public boolean isPossible;

        public State(int p, int q, int a, int b) {
            P = p;
            Q = q;
            this.a = a;
            this.b = b;
        }

        public State(int p, int q, int a, int b, State parent) {
            this(p, q, a, b);
            this.parent = parent;
            isPossible = parent.isPossible;
        }

        public State(int p, int q, int a, int b, boolean isPossible) {
            this(p, q, a, b);
            this.isPossible = isPossible;
        }

        private State getStateOnPStep() {
            if (P == 1) {
                // a = 1
                return new State(2, Q, 1, b, this);
            }
            if (P == 2) {
                // while b != 0; pass
                if (b != 0) return new State(2, Q, a, b, this);
                return new State(3, Q, a, b, this);
            }
            if (P == 3) {
                // pass
                return new State(4, Q, a, b, this);
            }
            if (P == 4) {
                // a = 0
                return new State(1, Q, 0, b, this);
            }
            // hehe, this is can't be
            throw new IllegalArgumentException(String.format("Get state with: P = %d Q = %d a = %d b = %d", P, Q, a, b));
        }

        private State getStateOnQStep() {
            if (Q == 1) {
                // b = 1
                return new State(P, 2, a, 1);
            }
            if (Q == 2) {
                // if a == 0: break
                if (a == 0) return new State(P, 4, a, b);
                return new State(P, 3, a, b);
            }
            if (Q == 3) {
                // b = 0
                return new State(P, 1, a, 0);
            }
            if (Q == 4) {
                return null;
            }
            // hehe, this is can't be
            throw new IllegalArgumentException(String.format("Get state with: P = %d Q = %d a = %d b = %d", P, Q, a, b));
        }

        public ArrayList<State> possibleGenerate() {
            ArrayList <State> possible = new ArrayList<>();
            State fromP = getStateOnPStep();
            State fromQ = getStateOnQStep();
            if (fromP != null) possible.add(fromP);
            if (fromQ != null) possible.add(fromQ);
            return possible;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            State state = (State) o;
            return P == state.P &&
                    Q == state.Q &&
                    a == state.a &&
                    b == state.b;
        }

        @Override
        public int hashCode() {
            return Objects.hash(P, Q, a, b);
        }

        @Override
        public String toString() {
            return String.format("[P%d,Q%d,%d,%d]", P, Q, a, b);
        }
    }

    private static void writeln(String s) throws IOException {
        writer.write(s);
        writer.newLine();
    }

    private static Set<State> states;

    public static void main(String[] args) throws IOException {
        if (args.length != 1) {
            System.err.println("Usage: <write only possible paths (true/false)>");
        }
        boolean writePossible = Boolean.parseBoolean(args[0]);
        writer = Files.newBufferedWriter(Path.of("solution.txt"), StandardCharsets.UTF_8);
        writeln("Kuznetsov Vladislav # <-- fill it in");
        writeln("# autogenerated file -> PossibleExecutions.java\n");
        states = new HashSet<>();
        LinkedList<State> queue = new LinkedList<>(Collections.singleton(new State(1, 1, 0, 0, true)));
        while (!queue.isEmpty()) {
            State state = queue.pollFirst();
            ArrayList<State> futureStates = state.possibleGenerate();
            for (State future : futureStates) {
                if (!states.contains(future)) {
                    states.add(future);
                    queue.add(future);
                }
            }
        }
        for (int P = 1; P < 5; P++) {
            writeln("# P = " + P + " position");
            for (int Q = 1; Q < 5; Q++) {
                writeln("\t# Q = " + Q + " position");
                for (int a = 0; a < 2; a++) {
                    writeln("\t\t# a = " + a + " position");
                    for (int b = 0; b < 2; b++) {
                        writeln("\t\t\t# b = " + b + " position");
                        State current = new State(P, Q, a, b);
                        if (writePossible && !states.contains(current)) {
                            continue;
                        }
                        boolean isPossible = states.contains(current);
                        ArrayList<State> futureStates = current.possibleGenerate();
                        for (State futureState : futureStates) {
                            writeln(String.format("\t\t\t\t%s -> %s # %s", current.toString(), futureState, isPossible ? "possible" : "not possible"));
                        }
                    }
                }
            }
        }
        writeln("\n\n\n# Count possible: " + states.size() + "\n\n");
        for (int a = 0; a < 2; a++) {
            for (int b = 0; b < 2; b++) {
                State state = new State(3, 4, a, b);
                if (states.contains(state)) {
                    writeln("# " + state.toString() + " is possible. Path: ");
                    while (state != null) {
                        writeln("# " + state.toString() + (state.parent != null ? " <- " : ""));
                        state = state.parent;
                    }
                }
            }
        }
        writeln("# 3) Нет, это невозможно, так как для достижения Q4 необходимо, что бы что бы a было равно 0, значит, в это время P находился в 1 или 2 строке, и b был равен 1. Значит, после этого b != 0 и мы будем вечно крутиться в 2 строки программы b");
        writeln("# 4) Да, везде это возможно, так как для посещения данной вершины нужно, что бы a = 0, такое достижимо из любого места, так как P никогда не прекращает менять a, а Q - b");
        writer.close();
    }
}
